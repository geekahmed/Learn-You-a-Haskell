
# Learn You a Haskell for Great Good! **A Beginner’s Guide**
This repository presents my learning and reading process for the well-known book by Miran Lipovaca  "Learn You a Haskell for Great Good!".
## Brief Content
- [Chapter 0. Introduction](#chapter-0-introduction)
- [Chapter 1. Starting Out](#Chapter-1-Starting-Out)
- [Chapter 2. Believe The Type](#chapter-2-believe-the-type)
- [Chapter 3. Syntax in Functions](#chapter-3-syntax-in-functions)
- [Chapter 4. Hello Recursion](#chapter-4-hello-recursion)
- [Chapter 5.  Higher-Order Functions](#chapter-5-higher-order-functions)
- [Chapter 6. Modules](#)
- [Chapter 7. Making Our Own Types and Type Classes](#)
- [Chapter 8. Input and Output](#)
- [Chapter 9. More Input and More Output](#)
- [Chapter 10. Functionality Solving Problems](#)
- [Chapter 11. Applicative Functors](#)
- [Chapter 12.  Monoids](#)
- [Chapter 13. A Fistful Of Monads](#)
- [Chapter 14. For A Few Monads More](#)
- [Chapter 15. Zippers](#)

# Chapter 0. Introduction
- Haskell is a purely functional programming language.
- In imperative programming languages, you give the computer a sequence of tasks, which it then executes. While executing them, the computer can change state.
- In functional programming languages, You don’t tell the computer what to do, you tell it what stuff is.
- In purely functional languages, a function has no side effects.
- Referential transparency is a property which describing that a function returns the same result every time it fed by the same parameters.
- Haskell is lazy. This means that unless specifically told otherwise, Haskell won’t execute functions until it needs to show you a result.
- Haskell is statically typed. This means that when you compile your program, the compiler knows which piece of code is a number, which is a string, and so on.
- Haskell uses a very good type system that has type inference. This means that you don’t need to explicitly label every piece of code with a type.
- Haskell is elegant and concise. Because it uses a lot of high-level concepts, Haskell programs are usually shorter than their imperative equivalents.
# Chapter 1. Starting Out
- When using "ghci" for arithmetic operations, we should wrap negative numbers with parentheses.
	-  For example, entering 5 * -3 will make GHCi yell at you, but entering 5 * (-3) will work just fine. 
- Haskell has the Boolean values True and False, and uses the && operator for conjunction (Boolean and), the || operator for disjunction (Boolean or), and the not operator to negate a True or False value.
- We can test two values for equality or inequality with the == and /= operators.
- == can compare any two literals with the same type only.
- `5 + 4.0` is a valid expression, because although 4.0 isn’t an integer, 5 is sneaky and can act like either an integer or a floating-point number. In this case, 5 adapts to match the type of the floating-point value 4.0.
- When calling prefix functions in Haskell, the function name comes first, then a space, then its parameters (also separated by spaces).
- Function application has the highest precedence of all the operations in Haskell.
- If a function takes two parameters, we can also call it as an infix function by surrounding its name with backticks (`).
	- `div 92 10` is equivalent to `92 `\`div\`` 10`
-  `bar (bar 3)`, it means that we’re first calling the bar function with 3 as the parameter, then passing that result to the bar function again. The equivalent expression in C would be something like `bar(bar(3))`.
- The syntax of a function definition is similar to that of a function call: the function name is followed by parameters, which are separated spaces. But then the parameter list is followed by the = operator, and the code that makes up the body of the function follows that.
	- `doubleMe x = x + x`
- Functions in Haskell don’t have to be defined in any particular order, so it doesn’t matter which function comes first in the "scriptName".hs file.
- Haskell’s if is an expression that must return a value, and not a statement.
- We usually use ' to denote either a strict version of a function (i.e., one that isn’t lazy), or a slightly modified version of a function or variable with a similar name.
-  In Haskell, functions can’t begin with capital letters.
-  The function that doesn’t take any parameters, we usually call it a definition or a name.
- Lists in Haskell are homogeneous data structures, which means they store several elements of the same type.
-  Use the let keyword to define a name in GHCi. Entering let a = 1 in GHCi is equivalent to writing a = 1 in a script, then loading it with :l.
- ++ operator is used for concatenation.
	- [1,2,3,4] ++ [9,10,11,12]
	- [1,2,3,4,9,10,11,12]
- In Haskell, strings are really just lists of characters. For example, the string "hello" is actually the same as the list ['h','e','l','l','o']. Because of this, we can use list functions on strings, which is really handy.
- To add something to the beginning of a list, we use the ":" opertator.
	- 'A':" SMALL CAT"
	- "A SMALL CAT"
-  The first argument to the : operator always needs to be a single item of the same type as the values in the list it’s being added to.
- [], [[]] and [[],[],[]] are all different things. The first is an empty list, the second is a list that contains one empty list, and the third is a list that contains three empty lists.
- If you want to get an element of a list by index, use the !! operator.
- Lists within a list can be of different lengths, but they can’t be of different types.
- Lists can be compared if the items they contain can be compared.
- The head function takes a list and returns its head, or first element.
	- head [1,2,3,4]
	- 1
- The tail function takes a list and returns its tail. In other words, it chops off a list’s head.
	- tail [1,2,3,4]
	- [2,3,4]
- The last function returns a list’s last element.
	- last [1,2,3,4]
	- 4
- The init function takes a list and returns everything except its last element.
	- init [1,2,3,4]
	- [1,2,3]
- When using head, tail, last, and init, be careful not to use them on empty lists.
- The length function takes a list and returns its length.
	- length [1,2,3,4]
	- 4
- The null function checks if a list is empty. If it is, it returns True, otherwise it returns False.
	- null []
	- True
- The reverse function reverses a list
	- reverse [1,2,3,4]
	- [4,3,2,1]
- The take function takes a number and a list. It extracts the specified number elements from the beginning of the list.
	- take 3 [1,2,3,4,5]
	- [1,2,3]
- The drop function works in a similar way, only it drops (at most) the specified number of elements from the beginning of a list.
	- drop 3 [1,2,3]
	- []
- The maximum function takes a list of items that can be put in some kind of order and returns the largest element.
	- minimum is the opposite.
- The sum function takes a list of numbers and returns their sum.
- The product function takes a list of numbers and returns their product.
- The elem function takes an item and a list of items and tells us if that item is an element of the list.
	- It’s usually called as an infix function because it’s easier to read that way.
	- 4 \`elem\` [1,2,3,4]
	- True
-  Ranges are used to make lists composed of elements that can be enumerated, or counted off in order.
	- [1..20]
	- [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
- To make a list with all the numbers from 20 down to 1, you can’t just  type [20..1], you have to type [20,19..1]. When you use a range without steps (like [20..1]), Haskell will start with an empty list and then keep increasing the starting element by one until it reaches or surpasses the end element in the range. Because 20 is already greater than 1, the result will just be an empty list.
- We can use ranges to make infinite lists by not specifying an upper limit.
	- [1..]
	- [1,2,3,4,5,6,7,8...]
- `cycle` takes a list and replicates its elements indefinitely to form an infinite list.
	- take 10 (cycle [1,2,3])
	- [1,2,3,1,2,3,1,2,3,1]
- `repeat` takes an element and produces an infinite list of just that element.
- `replicate` is an easier way to create a list composed of a single item. It takes the length of the list and the item to replicate.
	- replicate 3 10
	- [10,10,10]
	- 3 \`replicate\` 10
	- [10,10,10]
- List comprehensions are a way to filter, transform, and combine lists.
	- They are very similar to the math concept set comprehension.
	- [x*2 | x <- [1..10]]
	- [2,4,6,8,10,12,14,16,18,20]
- Predicates go at the end of the list comprehension and are separated from the rest of the comprehension by a comma.
	- [x*2 | x <- [1..10], x*2 >= 12]
	- [12,14,16,18,20]
-  Weeding out parts of lists using predicates is also called filtering.
- We use underscore (_) as a temporary variable to store the items as we draw them from the input list, since we don’t actually care about the values.
	- length' xs = sum [1 | _ <- xs]
- Tuples are used to store several heterogeneous elements as a single value.
	- They have a fixed size.
	- (50, 50.4, "hello", 'b')
	- There is no singleton tuple.
- fst takes a pair and returns its first component.
- snd takes a pair and returns its second component.
- The zip function is a way to produce a list of pairs.
	- It takes two lists, then “zips” them together into one list by joining the matching elements into pairs.
	- zip [1,3,4] [3,4,5]
	- [(1,3),(3,4),(4,5)]

# Chapter 2. Believe The Type
- We use ":t" command in order to examine the type of valid expressions.
	- :t 'a'
	- 'a' :: Char
- The :: operator here is read as “has type of.”
- When writing our own functions, we can choose to give them an explicit type declaration.
	- removeNonUppercase :: [Char] -> [Char]
	- removeNonUppercase st = [ c | c <- st, c \`elem\` ['A'..'Z']]
- Int stands for integer. It’s used for whole numbers. 7 can be an Int, but 7.2 cannot.
	-  Int is bounded, which means that it has a minimum value and a maximum value.
- Integer is also used to store integers, but it’s not bounded, so it can be used to represent really big numbers.
- Float is a real floating-point number with single precision.
- Double is a real floating-point number with double the precision.
- Bool is a Boolean type. It can have only two values: True and False.
- Char represents a Unicode character. It’s denoted by single quotes. A list of characters is a string.
-  Tuples are types, but their definition depends on their length as well as the types of their components.
- Type variables allow functions to operate on values of various types in a type-safe manner.
	- Functions that use type variables are called polymorphic functions.
- Although type variables can have names that are longer than one character, we usually give them names like a, b, c, d, and so on.
- A type class is an interface that defines some behavior.
	- If a type is an instance of a type class, then it supports and implements the behavior the type class describes.
-  If a function is composed of only special characters, it’s considered an infix function by default.
- It’s important to note that type classes are not the same as classes in object-oriented programming languages.
- Eq type class is used for types that support equality testing.
- Ord is a type class for types whose values can be put in some order.
- The compare function takes two values whose type is an Ord instance and returns an Ordering. 
	-  Ordering is a type that can be GT, LT, or EQ, which represent greater than, lesser than, or equal, respectively.
- Values whose types are instances of the Show type class can be represented as strings.
- Read can be considered the opposite type class of Show.
- Type annotations are a way to explicitly tell Haskell what the type of an expression should be.
	- We do this by adding :: to the end of the expression and then specifying a type.
- Enum instances are sequentially ordered types, their values can be enumerated.
- Instances of the Bounded type class have an upper bound and a lower bound, which can be checked by using the minBound and maxBound functions.
- Num is a numeric type class. Its instances can act like numbers.
	- To be an instance of Num, a type must already be in Show and Eq.
- The Floating type class includes the Float and Double types, which are used to store floating-point numbers.
- Integral is another numeric type class. the Integral class includes only integral (whole) numbers.

