
# Learn You a Haskell for Great Good! **A Beginner’s Guide**
This repository presents my learning and reading process for the well-known book by Miran Lipovaca  "Learn You a Haskell for Great Good!".
## Brief Content
- [Chapter 0. Introduction](#chapter-0-introduction)
- [Chapter 1. Starting Out](#Chapter-1-Starting-Out)
- [Chapter 2. Believe The Type](#chapter-2-believe-the-type)
- [Chapter 3. Syntax in Functions](#chapter-3-syntax-in-functions)
- [Chapter 4. Hello Recursion](#chapter-4-hello-recursion)
- [Chapter 5.  Higher-Order Functions](#chapter-5-higher-order-functions)
- [Chapter 6. Modules](#)
- [Chapter 7. Making Our Own Types and Type Classes](#)
- [Chapter 8. Input and Output](#)
- [Chapter 9. More Input and More Output](#)
- [Chapter 10. Functionality Solving Problems](#)
- [Chapter 11. Applicative Functors](#)
- [Chapter 12.  Monoids](#)
- [Chapter 13. A Fistful Of Monads](#)
- [Chapter 14. For A Few Monads More](#)
- [Chapter 15. Zippers](#)

# Chapter 0. Introduction
- Haskell is a purely functional programming language.
- In imperative programming languages, you give the computer a sequence of tasks, which it then executes. While executing them, the computer can change state.
- In functional programming languages, You don’t tell the computer what to do, you tell it what stuff is.
- In purely functional languages, a function has no side effects.
- Referential transparency is a property which describing that a function returns the same result every time it fed by the same parameters.
- Haskell is lazy. This means that unless specifically told otherwise, Haskell won’t execute functions until it needs to show you a result.
- Haskell is statically typed. This means that when you compile your program, the compiler knows which piece of code is a number, which is a string, and so on.
- Haskell uses a very good type system that has type inference. This means that you don’t need to explicitly label every piece of code with a type.
- Haskell is elegant and concise. Because it uses a lot of high-level concepts, Haskell programs are usually shorter than their imperative equivalents.
# Chapter 1. Starting Out

